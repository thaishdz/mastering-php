


[Buen post de Manu Pijierro](https://mpijierro.medium.com/psr-est√°ndares-en-php-ccde7d9014e6#:~:text=PSR-7%3A%20HTTP%20message%20interfaces,la%20base%20del%20desarrollo%20web.)


# ¬øQu√© son los PSRs?
> PSRs (PHP Standards Recommendations), define un conjunto de est√°ndares que facilitan el desarrollo de aplicaciones y la interoperabilidad entre proyectos.

# ¬øQui√©n define los PSRs?
Los est√°ndares de PHP est√°n definidos por el PHP -FIG (PHP-Framework Interop Group).

# Objetivos del PHP-FIG 
- Promover el ecosistema de PHP
- Definir est√°ndares basados en la investigaci√≥n, experimentaci√≥n y sobre todo en la experiencia del mundo real
- Facilitar la colaboraci√≥n entre programadores y proyectos.


# Listado de est√°ndares PSR

## PSR-0 Autoloading Standard (Status: Deprecated üõë)
Fue marcado como deprecated (obsoleto) el 21‚Äì10‚Äì2014 en favor de __PSR-4__. El est√°ndar PSR-0 describe los requisitos obligatorios (pr√°cticas y restricciones), que deben ser satisfechos para la interoperabilidad del autocargador, es decir, para la carga autom√°tica de clases.

Cuando programamos, lo m√°s normal es tener una clase por archivo. Antes de utilizar una clase PHP debe conocerla, es decir, debemos indicarle a PHP en que archivo se encuentra. Si el proyecto es peque√±o y tiene pocas dependencias, casi que nosotros de manera manual podemos decirle a PHP donde se encuentra cada clase pero, si el proyecto es grande y tiene muchas dependencias, puede ser realmente complicado.

Despu√©s de la introducci√≥n de los namespaces en PHP 5.3, fue cuando se propuso este est√°ndar para que en base a ciertas caracter√≠sticas definidas de cada namespace de cada clase, se pudiera ‚Äúautodescubrir‚Äù de forma autom√°tica cuando necesit√°ramos una instancia de dicha clase.

Es decir, PSR-0 viene a decirnos como definir los namespaces de cada clase para que PHP pueda hacer la ‚Äúmagia‚Äù necesaria para encontrarlas.

## PSR-1: Basic Coding Standard (Status: Accepted ‚úîÔ∏è)
> Este est√°ndar comprende como deber√≠a ser la codificaci√≥n de los elementos necesarios para asegurar la interoperabilidad de c√≥digo compartido. 

Es decir, indican normas de codificaci√≥n b√°sica a muy bajo nivel como por ejemplo la codificaci√≥n de caracteres en UTF-8 o el tipo de escritura que deben seguir los nombres de las clases (StudlyCaps) o m√©todos (camelCase).

## PSR-2: Coding Style Guide (Status: Accepted ‚úîÔ∏è)
> Este est√°ndar extiende a PSR-1. La finalidad de PSR-2 es reducir la carga cognitiva que supone leer y entender c√≥digo de diferentes desarrolladores.

Para ello, enumera unas normas de estilo b√°sicas que consiguen hacer que el c√≥digo de un proyecto sea m√°s sim√©trico y predecible. En PHP, PSR-2 suponen las normas m√°s b√°sicas de codificaci√≥n que un equipo de desarrollo debiera tener en cuenta a la hora de programar.

## PSR-3: Looger Interface (Status: Accepted ‚úîÔ∏è)
Entendemos por ‚Äòlog‚Äô al registro o grabaci√≥n secuencial en un sistema de persistencia eventos que ocurren en nuestro sistema, de manera que posteriormente puedan ser procesados y obtener as√≠ las evidencias que sean oportunas.

PSR-3 define un interface com√∫n para librer√≠as de loggin de manera que pueda utilizarse esta funcionalidad en cualquier aplicaci√≥n de forma sencilla. Cada librer√≠a de log, posteriormente, puede estar implementada como mejor considere, pero, para asegurarse que cualquier aplicaci√≥n pueda usarla sin problemas debe cumplir PSR-3.

La definici√≥n de Logger Interface expone ocho m√©todos (debug, info, notice, warning, error, critical, alert, emergency), correspondientes a los ocho niveles de log definidos en el RF 5424.

Es decir, si queremos implementar una librer√≠a de log que sea compatible con otras aplicaciones, debe cumplir con PSR-3. Y si usamos una librer√≠a de loggin que cumpla PSR-3 sabemos que debe funcionar.

Ejemplo de [Logger Inteface](https://github.com/php-fig/log)


## PSR-4: Autoloader (Status: Accepted ‚úîÔ∏è)
Muy relacionada con PSR-0. En este caso, PSR-4 describe tambi√©n una especificaci√≥n sobre como tiene que ser la autocarga de clases.

Es compatible con PSR-0, aunque con otras caracter√≠sticas que lo mejoran. Entre sus diferencias m√°s notables tenemos por ejemplo que PSR-0 mantiene compatibilidades con caracter√≠sticas de PEAR mientras que PSR-4 las elimina. Tambi√©n, PSR-0 obliga a mantener una estructura de directorios similar al espacio de nombres definido mientras que PSR-4 no.

En este [enlace](https://stackoverflow.com/questions/24868586/what-are-the-differences-between-psr-0-and-psr-4) se pueden observar m√°s diferencias.

### Traducci√≥n

Son muy similares, por lo que no es sorprendente que sea un poco confuso. El resumen es que PSR-0 ten√≠a algunas caracter√≠sticas de compatibilidad retroactiva para nombres de clases al estilo PEAR que PSR-4 elimin√≥; por lo tanto, PSR-4 solo admite c√≥digo con namespaces. Adem√°s, PSR-4 no te obliga a que todo el namespace sea una estructura de directorios, solo la parte que sigue al punto de anclaje.

Por ejemplo, si defines que el namespace `Acme\Foo\` est√° anclado en `src/`, con PSR-0 significa que buscar√° `Acme\Foo\Bar` en `src/Acme/Foo/Bar.php`, mientras que en PSR-4 lo buscar√° en `src/Bar.php`, lo que permite estructuras de directorios m√°s cortas. Por otro lado, algunos prefieren tener toda la estructura de directorios para ver claramente qu√© est√° en cada namespace, por lo que tambi√©n puedes decir que `Acme\Foo\` est√° en `src/Acme/Foo` con PSR-4, lo cual te dar√° un comportamiento equivalente al descrito con PSR-0.

En resumen, para nuevos proyectos y para la mayor√≠a de los casos, puedes usar PSR-4 y olvidarte de PSR-0.

### ¬øQu√© es PEAR-STYLE?

El estilo PEAR (PHP Extension and Application Repository) es un est√°ndar de nomenclatura y organizaci√≥n de archivos en PHP utilizado antes de la adopci√≥n general de namespaces. En el estilo PEAR, las clases y sus nombres se organizaban en una jerarqu√≠a de directorios que reflejaba el nombre completo de la clase.

**Ejemplo de PEAR-Style:**

Si tienes una clase llamada `Foo_Bar`, su archivo se colocar√≠a en un directorio basado en el nombre de la clase, como `Foo/Bar.php`.

```php
// PEAR-style classname
class Foo_Bar {
    // C√≥digo de la clase
}
```

Este estilo fue popular antes de que se adoptaran los namespaces en PHP, pero se volvi√≥ menos com√∫n con la llegada de PSR-0 y PSR-4, que promueven una estructura de directorios y una organizaci√≥n de clases m√°s moderna y flexible.


# PSR-17: HTTP Factories (Status: Accepted ‚úîÔ∏è)
> Describe un est√°ndar com√∫n para factor√≠as que crean objetos HTTP compatibles con PSR-7 ya que este no incluye recomendaciones sobre como crear objetos HTTP dificultando el crear nuevos objetos HTTP en componentes que no est√©n vinculados a PSR-7.

M√°s informaci√≥n en el siguiente [enlace](https://www.php-fig.org/psr/psr-17/meta/)

# PSR-18: HTTP Client (Status: Accepted ‚úîÔ∏è)
> Este est√°ndar trata de describir un interface com√∫n para el env√≠o de peticiones HTTP y la recepci√≥n de respuestas HTTP.
Con PSR-7 sabemos que las peticiones y las respuestas se parecen, pero no define nada sobre como una petici√≥n deber√≠a ser enviada o recibida. Gracias a PSR-18 y a los clientes HTTP que lo implementen, los programadores podr√°n desarrollar librer√≠as desacopladas de las distintas implementaciones particulares de cada cliente HTTP, lo que har√° que dichas librer√≠as sean m√°s reutilizables.
